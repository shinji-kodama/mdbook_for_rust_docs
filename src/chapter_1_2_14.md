# 所有権システム

値は原則として1つの変数のみが保持できる

## 所有権・借用
    
### `所有権`を持っている
変数がある値を保持している状態
    
- 変数から変数に所有権を移動することをムーブという

- 変数のあるスコープを抜けるときに所有権が移動しなければ、値は破棄されメモリは解放される 

- **ガベージコレクションなしでも安全なメモリ管理ができる**

- ある変数を関数などで利用するために常に所有権の移動を行うと不便なため`借用`もできる

### `借用`
所有権を移動せず値を参照する仕組み

`let w = &z`の様に、変数の前に`&`をつけることで借用できる

```rust
fn main() {
    {
        // 所有権の移動
        let x = String::from("hello");
        let y = x; // ここでムーブ

        // xの所有権はyに移動済みなのでxは使えない
        // println!("{}", x);
        println!("y:{}", y);
    } // yもここで解放される

    {
        // 借用
        let z = String::from("hello");
        {
            let w = &z; // ここで借用
            
            // let s = z; // (d3)
            println!("w:{}", w);
        } // wはここで解放される
          // zはまだ使用可能
        println!("z:{}", z);
    } // zはここで解放される
}
```

## ライフタイム

### `Borrow checker`
値の所有期間（ライフタイム）を制御フローから決定

- 不整合があるとコンパイルエラーを出す（借用時にムーブさせようとするとか）

- ライフタイムは基本的に自動で決定されるが、以下のように明示的に指定することも可能

- 下の例ではgreetが先にメモリ解放されて、その後にhelloが開放されるのでコンパイルが通る

```rust
struct Greet<'a> {
    // &str型 参照なのでGreetの生存期間より長く存在する必要あり
    // このことをコンパイラに伝えるため、ライフタイムパラメータ`aが付加されている
    word: &'a str,   
}

impl<'a> Greet<'a> {
    fn say(&self) {
        println!("{}", self.word);
    }
}

fn main() {
    let hello: &str = "Hello!";　
    {
        let greet = Greet { word: hello };
        greet.say();
    } // greetはここで解放される

    println!("{}", hello);
} // helloはここで解放される
``` 
